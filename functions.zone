#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2010  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

function zone_dir() {
	local zone=${1}

	echo "${ZONE_DIR}/${zone}"
}

function zone_exists() {
	local zone=${1}

	[ -d "$(zone_dir ${zone})" ]
}

function zone_match() {
	local match

	local i
	for i in ${VALID_ZONES}; do
		match="${match}|${i}[0-9]{1,5}"
	done

	echo "${match:1:${#match}}"
}

function zone_name_is_valid() {
	local zone=${1}

	[[ ${zone} =~ $(zone_match) ]]
}

function zone_is_local() {
	local zone=${1}

	! zone_is_nonlocal ${zone}
}

function zone_is_nonlocal() {
	local zone=${1}

	[[ ${zone} =~ ^red[0-9]{1,5} ]]
}

function zone_get_hook() {
	local zone=${1}

	config_get_hook $(zone_dir ${zone})/settings
}

function zone_create() {
	local zone=${1}
	local hook=${2}
	shift 2

	if ! zone_name_is_valid ${zone}; then
		error "Zone name '${zone}' is not valid."
		return ${EXIT_ERROR}
	fi

	if zone_exists ${zone}; then
		error "Zone '${zone}' does already exist."
		return ${EXIT_ERROR}
	fi

	if ! hook_exists ${hook}; then
		error "Hook '${hook}' does not exist."
		return ${EXIT_ERROR}
	fi

	mkdir -p $(zone_dir ${zone})

	hook_exec ${hook} create ${zone} $@
	local ret=$?

	# Maybe the zone create hook did not exit correctly.
	# If this is the case we remove the created zone immediately.
	if [ "${ret}" = "${EXIT_ERROR}" ]; then
		zone_remove ${zone}
	fi
}

function zone_edit() {
	local zone=${1}
	shift

	if ! zone_exists ${zone}; then
		error "Zone '${zone}' does not exist."
		return ${EXIT_ERROR}
	fi

	local hook=$(config_get_hook $(zone_dir ${zone})/settings)

	if [ -z "${hook}" ]; then
		error "Config file did not provide any hook."
		return ${EXIT_ERROR}
	fi

	if ! hook_exists ${hook}; then
		error "Hook '${hook}' does not exist."
		return ${EXIT_ERROR}
	fi

	hook_exec ${hook} edit ${zone} $@
}

function zone_remove() {
	local zone=${1}
	shift

	if ! zone_exists ${zone}; then
		error "Zone '${zone}' does not exist."
		return ${EXIT_ERROR}
	fi

	# XXX Tear this down here?

	rm -rf $(zone_dir ${zone})
}

function zone_up() {
	local zone=${1}
	shift

	if ! zone_exists ${zone}; then
		error "Zone '${zone}' does not exist."
		return ${EXIT_ERROR}
	fi

	local hook=$(config_get_hook $(zone_dir ${zone})/settings)

	if [ -z "${hook}" ]; then
		error "Config file did not provide any hook."
		return ${EXIT_ERROR}
	fi

	if ! hook_exists ${hook}; then
		error "Hook '${hook}' does not exist."
		return ${EXIT_ERROR}
	fi

	zone_db ${zone} starting

	hook_exec ${hook} up ${zone} $@
	
	zone_db ${zone} started
}

function zone_down() {
	local zone=${1}
	shift

	if ! zone_exists ${zone}; then
		error "Zone '${zone}' does not exist."
		return ${EXIT_ERROR}
	fi

	local hook=$(config_get_hook $(zone_dir ${zone})/settings)

	if [ -z "${hook}" ]; then
		error "Config file did not provide any hook."
		return ${EXIT_ERROR}
	fi

	if ! hook_exists ${hook}; then
		error "Hook '${hook}' does not exist."
		return ${EXIT_ERROR}
	fi

	zone_db ${zone} stopping

	hook_exec ${hook} down ${zone} $@

	zone_db ${zone} stopped
}

function zone_status() {
	local zone=${1}
	shift

	if ! zone_exists ${zone}; then
		error "Zone '${zone}' does not exist."
		return ${EXIT_ERROR}
	fi

	local hook=$(config_get_hook $(zone_dir ${zone})/settings)

	if [ -z "${hook}" ]; then
		error "Config file did not provide any hook."
		return ${EXIT_ERROR}
	fi

	if ! hook_exists ${hook}; then
		error "Hook '${hook}' does not exist."
		return ${EXIT_ERROR}
	fi

	hook_exec ${hook} status ${zone} $@
}

function zone_port() {
	local zone=${1}
	shift

	if ! zone_exists ${zone}; then
		error "Zone '${zone}' does not exist."
		return ${EXIT_ERROR}
	fi

	local hook=$(config_get_hook $(zone_dir ${zone})/settings)

	if [ -z "${hook}" ]; then
		error "Config file did not provide any hook."
		return ${EXIT_ERROR}
	fi

	if ! hook_exists ${hook}; then
		error "Hook '${hook}' does not exist."
		return ${EXIT_ERROR}
	fi

	hook_exec ${hook} port ${zone} $@
}

function zone_config() {
	local zone=${1}
	shift

	if ! zone_exists ${zone}; then
		error "Zone '${zone}' does not exist."
		return ${EXIT_ERROR}
	fi

	local hook=$(config_get_hook $(zone_dir ${zone})/settings)

	if [ -z "${hook}" ]; then
		error "Config file did not provide any hook."
		return ${EXIT_ERROR}
	fi

	if ! hook_exists ${hook}; then
		error "Hook '${hook}' does not exist."
		return ${EXIT_ERROR}
	fi

	hook_exec ${hook} config ${zone} $@
}

function zone_show() {
	local zone=${1}

	echo "${zone}"
	echo "  Type: $(zone_get_hook ${zone})"
	echo
}

function zones_show() {
	local zone

	for zone in $(zones_get $@); do
		zone_show ${zone}
	done
}

function zones_get_all() {
	local zone
	for zone in ${ZONE_DIR}/*; do
		zone=$(basename ${zone})
		zone_exists ${zone} || continue

		echo "${zone}"
	done | sort
}

function zones_get_local() {
	local zone
	for zone in $(zones_get_all); do
		zone_is_local ${zone} && echo "${zone}"
	done
}

function zones_get_nonlocal() {
	local zone
	for zone in $(zones_get_all); do
		zone_is_nonlocal ${zone} && echo "${zone}"
	done
}

function zones_get() {
	local local=1
	local remote=1

	local zones

	while [ $# -gt 0 ]; do
		case "${1}" in
			--local-only)
				local=1
				remote=0
				;;
			--remote-only)
				local=0
				remote=1
				;;
			--all)
				local=1
				remote=1
				;;
			*)
				if zone_name_is_valid ${1}; then
					zones="${zones} ${1}"
				else			
					warning "Unrecognized argument '${1}'"
				fi
				;;
		esac
		shift
	done

	if [ -n "${zones}" ]; then
		local zone
		for zone in ${zones}; do
			zone_exists ${zone} && echo "${zone}"
		done
		exit ${EXIT_OK}
	fi

	if [ ${local} -eq 1 ] && [ ${remote} -eq 1 ]; then
		zones_get_all
	elif [ ${local} -eq 1 ]; then
		zones_get_local
	elif [ ${remote} -eq 1 ]; then
		zones_get_nonlocal
	fi
}

function zone_ports_list() {
	local zone=${1}

	local port
	for port in $(zone_dir ${zone})/port.*; do
		[ -e "${port}" ] || continue

		echo $(basename ${port})
	done | sort
}

function zone_ports_cmd() {
	local cmd=${1}
	local zone=${2}
	shift 2

	local hook_zone=$(config_get_hook $(zone_dir ${zone})/settings)

	local hook_port
	local port
	for port in $(zone_ports_list ${zone}); do
		hook_port=$(config_get_hook $(zone_dir ${zone})/${port})

		hook_port_exec ${hook_zone} ${hook_port} ${cmd} ${zone} ${port} $@
	done
}

function zone_ports_up() {
	zone_ports_cmd up $@
}

function zone_ports_down() {
	zone_ports_cmd down $@
}

function zone_configs_list() {
	local zone=${1}

	local config
	for config in $(zone_dir ${zone})/config.*; do
		[ -e "${config}" ] || continue

		echo $(basename ${config})
	done | sort
}

function zone_configs_cmd() {
	local cmd=${1}
	local zone=${2}
	shift 2

	local hook_zone=$(config_get_hook $(zone_dir ${zone})/settings)

	local hook_config
	local config
	for config in $(zone_configs_list ${zone}); do
		hook_config=$(config_get_hook $(zone_dir ${zone})/${config})

		hook_config_exec ${hook_zone} ${hook_config} ${cmd} ${zone} ${config} $@
	done
}

function zone_configs_up() {
	zone_configs_cmd up $@
}

function zone_configs_down() {
	zone_configs_cmd down $@
}

function zone_has_ipv4() {
	device_has_ipv4 $@
}

function zone_has_ipv6() {
	device_has_ipv6 $@
}

function zone_db() {
	local zone=${1}
	local action=${2}
	shift 2

	case "${action}" in
		starting|started|stopping|stopped)
			db_connection_update ${zone} ${action}
			;;
	esac
}

function zone_is_up() {
	local zone=${1}

	device_is_up ${zone}
}

function zone_is_down() {
	! zone_is_up $@
}

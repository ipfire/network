#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2010  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

function zone_dir() {
	local zone=${1}

	echo "${NETWORK_ZONE_DIR}/zones/${zone}"
}

function zone_exists() {
	local zone=${1}
	assert isset zone

	[ -d "$(zone_dir ${zone})" ]
}

function zone_match() {
	local match

	local i
	for i in ${VALID_ZONES}; do
		match="${match}|${i}[0-9]{1,5}"
	done

	echo "${match:1:${#match}}"
}

function zone_name_is_valid() {
	local zone=${1}

	# Don't accept empty strings.
	[ -z "${zone}" ] && return ${EXIT_FALSE}

	[[ ${zone} =~ $(zone_match) ]]
}

function zone_is_local() {
	local zone=${1}

	[[ "${zone:0:${#ZONE_LOCAL}}" = "${ZONE_LOCAL}" ]]
}

function zone_is_nonlocal() {
	local zone=${1}

	[[ "${zone:0:${#ZONE_NONLOCAL}}" = "${ZONE_NONLOCAL}" ]]
}

function zone_get_hook() {
	local zone=${1}
	assert isset zone

	config_get_hook $(zone_dir ${zone})/settings
}

function zone_start() {
	# This function will bring up the zone
	# 'asynchronously' with help of systemd.

	local zone=${1}
	assert zone_exists ${zone}

	service_start "network@${zone}.service"
}

function zone_start_auto() {
	local zone="${1}"
	assert zone_exists "${zone}"

	# If the zone has already been started, we
	# will reload it so the current configuration
	# is re-applied.
	if zone_is_active "${zone}"; then
		zone_reload "${zone}"
		return ${?}

	# If the zone is still down, but in auto-start mode,
	# we will start it.
	elif zone_is_enabled "${zone}"; then
		zone_start "${zone}"
		return ${?}
	fi

	# Otherwise, nothing will be done.
	return ${EXIT_OK}
}

function zone_stop() {
	# This function will bring down the zone
	# 'asynchronously' with help of systemd.

	local zone=${1}
	assert zone_exists ${zone}

	service_stop "network@${zone}.service"
}

function zone_reload() {
	local zone="${1}"
	assert zone_exists "${zone}"

	service_reload "network@${zone}.service"
}

function zone_hotplug_event() {
	local zone="${1}"
	assert isset zone

	hotplug_assert_in_hotplug_event

	zone_cmd "hotplug" "${zone}"
}

function zone_enable() {
	# This function will enable the zone
	# with help of systemd.

	local zone="${1}"
	assert zone_exists "${zone}"

	# Enable service for the zone
	service_enable "network@${zone}.service"
	local ret=$?

	if [ ${ret} -eq ${EXIT_OK} ]; then
		log INFO "Auto-start enabled for zone ${zone}"
		return ${EXIT_OK}
	fi

	log ERROR "Could not enable zone ${zone}: ${ret}"
	return ${ret}
}

function zone_disable() {
	# This function will disable the zone
	# with help of systemd.

	local zone="${1}"
	assert zone_exists "${zone}"

	# Disable service for the zone
	service_disable "network@${zone}.service"
	local ret=$?

	if [ ${ret} -eq ${EXIT_OK} ]; then
		log INFO "Auto-start disabled for zone ${zone}"
		return ${EXIT_OK}
	fi

	log ERROR "Could not disable zone ${zone}: ${ret}"
	return ${ret}
}

function zone_is_enabled() {
	local zone="${1}"
	assert isset zone

	# Ask systemd if the zone is enabled.
	if service_is_enabled "network@${zone}.service"; then
		return ${EXIT_TRUE}
	fi

	return ${EXIT_FALSE}
}

function zone_is_active() {
	local zone="${1}"
	assert isset zone

	if service_is_active "network@${zone}.service"; then
		return ${EXIT_TRUE}
	fi

	return ${EXIT_FALSE}
}

function zone_is_enabled_or_active() {
	local zone="${1}"
	assert isset zone

	zone_is_enabled "${zone}" || zone_is_active "${zone}"
}

function zone_cmd() {
	local cmd="${1}"
	local port="${2}"
	shift 2

	assert isset cmd
	assert isset zone

	local hook="$(zone_get_hook ${zone})"
	assert isset hook

	hook_exec zone "${hook}" "${cmd}" "${zone}" $@
}

function zone_new() {
	local zone=${1}
	local hook=${2}
	shift 2

	if ! zone_name_is_valid ${zone}; then
		error "Zone name '${zone}' is not valid."
		return ${EXIT_ERROR}
	fi

	if zone_exists ${zone}; then
		error "Zone '${zone}' does already exist."
		return ${EXIT_ERROR}
	fi

	if ! hook_zone_exists ${hook}; then
		error "Hook '${hook}' does not exist."
		return ${EXIT_ERROR}
	fi

	mkdir -p $(zone_dir ${zone})

	# Create directories for configs and ports
	mkdir -p $(zone_dir ${zone})/{configs,ports}

	hook_zone_exec "${hook}" "new" "${zone}" $@
	local ret=$?

	# Maybe the zone new hook did not exit correctly.
	# If this is the case we remove the created zone immediately.
	if [ "${ret}" = "${EXIT_ERROR}" ]; then
		zone_destroy_now "${zone}"
		return ${EXIT_ERROR}
	fi

	# Automatically enable zone.
	zone_enable "${zone}"

	# Bring up the zone immediately after
	zone_start "${zone}"
}

function zone_edit() {
	local zone=${1}
	shift

	if ! zone_exists ${zone}; then
		error "Zone '${zone}' does not exist."
		return ${EXIT_ERROR}
	fi

	# Check if the zone is tagged for removal.
	if zone_has_destroy_tag ${zone}; then
		error "You cannot edit a zone that is tagged for removal."
		return ${EXIT_ERROR}
	fi

	local hook="$(zone_get_hook "${zone}")"
	if [ -z "${hook}" ]; then
		error "Config file did not provide any hook."
		return ${EXIT_ERROR}
	fi

	if ! hook_zone_exists ${hook}; then
		error "Hook '${hook}' does not exist."
		return ${EXIT_ERROR}
	fi

	hook_zone_exec ${hook} edit ${zone} $@
}


function zone_destroy() {
	local zone="${1}"
	assert zone_exists "${zone}"

	# Make the zone for removal.
	touch "$(zone_dir "${zone}")/.destroy"

	log INFO "Zone '${zone}' has been tagged for removal."
}

function zone_has_destroy_tag() {
	local zone="${1}"
	assert zone_exists "${zone}"

	[ -e "$(zone_dir "${zone}")/.destroy" ]
}

# This function will remove the given zone
# RIGHT NOW. Use zone_destroy to remove it
# at the next status change.
function zone_destroy_now() {
	local zone="${1}"
	assert zone_exists "${zone}"

	log INFO "Removing zone '${zone}' right now."

	# Force the zone down.
	zone_is_active "${zone}" && zone_stop "${zone}"

	# Disable zone.
	zone_disable "${zone}"

	rm -rf "$(zone_dir "${zone}")"
}

function zone_up() {
	local zone=${1}
	shift

	if ! zone_exists ${zone}; then
		error "Zone '${zone}' does not exist."
		return ${EXIT_ERROR}
	fi

	# Check if a zone has got the remove tag.
	if zone_has_destroy_tag ${zone}; then
		error "Cannot bring up any zone which is to be removed."
		return ${EXIT_ERROR}
	fi

	local hook="$(zone_get_hook "${zone}")"
	if [ -z "${hook}" ]; then
		error "Config file did not provide any hook."
		return ${EXIT_ERROR}
	fi

	if ! hook_zone_exists ${hook}; then
		error "Hook '${hook}' does not exist."
		return ${EXIT_ERROR}
	fi

	zone_db ${zone} starting

	hook_zone_exec ${hook} up ${zone} $@

	zone_db ${zone} started
}

function zone_down() {
	local zone=${1}
	shift

	if ! zone_exists ${zone}; then
		error "Zone '${zone}' does not exist."
		return ${EXIT_ERROR}
	fi

	local hook="$(zone_get_hook "${zone}")"
	if [ -z "${hook}" ]; then
		error "Config file did not provide any hook."
		return ${EXIT_ERROR}
	fi

	if ! hook_zone_exists ${hook}; then
		error "Hook '${hook}' does not exist."
		return ${EXIT_ERROR}
	fi

	zone_db ${zone} stopping

	hook_zone_exec ${hook} down ${zone} $@

	zone_db ${zone} stopped

	# Remove the zone, if it has got a remove tag.
	if zone_has_destroy_tag "${zone}"; then
		zone_destroy_now "${zone}"
	fi
}

function zone_status() {
	local zone="${1}"
	assert isset zone
	shift

	if ! zone_exists "${zone}"; then
		error "Zone '${zone}' does not exist."
		return ${EXIT_ERROR}
	fi

	local hook="$(zone_get_hook "${zone}")"
	if [ -z "${hook}" ]; then
		error "Config file did not provide any hook."
		return ${EXIT_ERROR}
	fi

	if ! hook_zone_exists "${hook}"; then
		error "Hook '${hook}' does not exist."
		return ${EXIT_ERROR}
	fi

	hook_zone_exec "${hook}" "status" "${zone}" "$@"

	# Show that the zone it to be removed soon.
	if zone_has_destroy_tag ${zone}; then
		warning "This zone is tagged for removal."
	fi
}

function zone_get_ports() {
	local zone=${1}

	assert isset zone

	local port
	for port in $(zone_dir ${zone})/ports/*; do
		port=$(basename ${port})

		if port_exists ${port}; then
			echo "${port}"
		fi
	done
}

function zone_get_ports_num() {
	local zone="${1}"
	assert isset zone

	local counter=0
	local port
	for port in $(zone_dir "${zone}")/ports/*; do
		port="$(basename "${port}")"

		if port_exists "${port}"; then
			counter=$(( ${counter} + 1 ))
		fi
	done

	echo "${counter}"
	return ${EXIT_OK}
}

function zone_has_port() {
	# Check, if the given port is configured
	# in this zone.

	local zone=${1}
	local port=${2}
	shift 2

	assert isset zone
	assert isset port

	[ -e "$(zone_dir ${zone})/ports/${port}" ]
}

function zone_config() {
	local zone="${1}"
	local cmd="${2}"
	shift 2

	assert isset zone
	assert isset cmd
	assert zone_exists "${zone}"

	case "${cmd}" in
		create)
			zone_config_create "${zone}" "$@"
			;;
		edit)
			zone_config_edit "${zone}" "$@"
			;;
		remove)
			zone_config_remove "${zone}" "$@"
			;;
		*)
			error "Unrecognized argument: ${cmd}"
			cli_usage root-zone-config-subcommands
			exit ${EXIT_ERROR}
			;;
	esac
}

function zone_config_cmd() {
	assert [ $# -gt 2 ]

	local cmd="${1}"
	local zone="${2}"
	shift 2

	local hook="$(zone_get_hook "${zone}")"
	assert isset hook

	hook_zone_exec "${hook}" "config_${cmd}" "${zone}" "$@"
}

function zone_config_create() {
	zone_config_cmd "create" "$@"
}

function zone_config_edit() {
	zone_config_cmd "edit" "$@"
}

function zone_config_remove() {
	zone_config_cmd "remove" "$@"
}

function zone_config_show() {
	zone_config_cmd "show" "$@"
}

function zone_show() {
	local zone=${1}

	echo "${zone}"
	echo "  Type: $(zone_get_hook ${zone})"
	echo
}

function zones_show() {
	local zone

	for zone in $(zones_get $@); do
		zone_show ${zone}
	done
}

function zones_get_all() {
	local zone
	for zone in $(zone_dir)/*; do
		zone=$(basename ${zone})
		zone_exists ${zone} || continue

		echo "${zone}"
	done
}

function zones_get_local() {
	local zone
	for zone in $(zones_get_all); do
		zone_is_local ${zone} && echo "${zone}"
	done
}

function zones_get_nonlocal() {
	local zone
	for zone in $(zones_get_all); do
		zone_is_nonlocal ${zone} && echo "${zone}"
	done
}

function zones_get() {
	local local=1
	local remote=1

	local zones

	while [ $# -gt 0 ]; do
		case "${1}" in
			--local-only)
				local=1
				remote=0
				;;
			--remote-only)
				local=0
				remote=1
				;;
			--all)
				local=1
				remote=1
				;;
			*)
				if zone_name_is_valid ${1}; then
					zones="${zones} ${1}"
				else			
					warning "Unrecognized argument '${1}'"
				fi
				;;
		esac
		shift
	done

	if [ -n "${zones}" ]; then
		local zone
		for zone in ${zones}; do
			zone_exists ${zone} && echo "${zone}"
		done
		exit ${EXIT_OK}
	fi

	if [ ${local} -eq 1 ] && [ ${remote} -eq 1 ]; then
		zones_get_all
	elif [ ${local} -eq 1 ]; then
		zones_get_local
	elif [ ${remote} -eq 1 ]; then
		zones_get_nonlocal
	fi
}

function zone_ports_list() {
	local zone=${1}

	local port
	for port in $(zone_dir ${zone})/ports/*; do
		[ -e "${port}" ] || continue

		echo $(basename ${port})
	done
}

function zone_port_attach() {
	local zone="${1}"
	assert isset zone

	local port="${2}"
	assert isset port

	shift 2

	# Check if the port actually exists.
	if ! port_exists "${port}"; then
		error "Cannot attach port '${port}' which does not exist"
		return ${EXIT_ERROR}
	fi

	# Check if the port is already connected to this or any other zone.
	local z
	for z in $(zones_get_all); do
		if zone_has_port "${z}" "${port}"; then
			error "Port '${port}' is already attached to zone '${z}'"
			return ${EXIT_ERROR}
		fi
	done

	local hook="$(zone_get_hook "${zone}")"
	assert isset hook

	hook_zone_exec "${hook}" "port_attach" "${zone}" "${port}" "$@"
	local ret="${?}"

	case "${ret}" in
		${EXIT_OK})
			log INFO "${port} has been attached to ${zone}"

			# Automatically connect the port
			if zone_is_active "${zone}"; then
				zone_port_create "${zone}" "${port}"
			fi
			;;
		*)
			log CRITICAL "${port} could not be attached to ${zone}"
			;;
	esac

	return ${ret}
}

function zone_port_edit() {
	local zone="${1}"
	assert isset zone

	local port="${2}"
	assert isset port

	shift 2

	# Check if the port actually exists.
	if ! port_exists "${port}"; then
		error "Port '${port}' does not exist"
		return ${EXIT_ERROR}
	fi

	# Check if the zone actually has this port.
	if ! zone_has_port "${zone}" "${port}"; then
		error "Port '${port}' is not attached to zone '${zone}'"
		return ${EXIT_ERROR}
	fi

	local hook=$(zone_get_hook "${zone}")
	assert isset hook

	hook_zone_exec "${hook}" "port_edit" "${zone}" "${port}" "$@"
}

function zone_port_detach() {
	local zone="${1}"
	assert isset zone

	local port="${2}"
	assert isset port

	shift 2

	# Check if the zone actually has this port.
	if ! zone_has_port "${zone}" "${port}"; then
		error "Port '${port}' is not attached to zone '${zone}'"
		return ${EXIT_ERROR}
	fi

	local hook=$(zone_get_hook "${zone}")
	assert isset hook

	hook_zone_exec "${hook}" "port_detach" "${zone}" "${port}" "$@"
	local ret="${?}"

	case "${ret}" in
		${EXIT_OK})
			log INFO "${port} has been detached from ${zone}"

			# Bring down the port if needed
			if zone_is_active "${zone}"; then
				zone_port_remove "${zone}" "${port}"
			fi
			;;
		*)
			log CRITICAL "${port} could not be detached from ${zone}"
			;;
	esac

	return ${ret}
}

function zone_port_cmd() {
	local cmd="${1}"
	assert isset cmd

	local zone="${2}"
	assert isset zone

	local port="${3}"
	assert isset port

	shift 3

	local hook="$(zone_get_hook "${zone}")"
	assert isset hook

	# Dispatch command to hook
	hook_zone_exec "${hook}" "${cmd}" "${zone}" "${port}" $@
}

function zone_port_create() {
	zone_port_cmd "port_create" $@
}

function zone_port_remove() {
	zone_port_cmd "port_remove" $@
}

function zone_port_up() {
	zone_port_cmd "port_up" $@
}

function zone_port_down() {
	zone_port_cmd "port_down" $@
}

function zone_port_status() {
	zone_port_cmd "port_status" $@
}

function zone_ports_cmd() {
	local cmd="${1}"
	assert isset cmd

	local zone="${2}"
	assert isset zone

	shift 2

	local hook="$(zone_get_hook "${zone}")"

	local port
	for port in $(zone_get_ports ${zone}); do
		hook_zone_exec "${hook}" "${cmd}" "${zone}" "${port}" $@
	done
}

function zone_ports_create() {
	zone_ports_cmd "port_create" $@
}

function zone_ports_remove() {
	zone_ports_cmd "port_remove" $@
}

function zone_ports_up() {
	zone_ports_cmd "port_up" $@
}

function zone_ports_down() {
	zone_ports_cmd "port_down" $@
}

function zone_ports_status() {
	zone_ports_cmd "port_status" $@
}

function zone_configs_cmd() {
	assert [ $# -ge 2 ]

	local cmd="${1}"
	local zone="${2}"
	shift 2

	assert zone_exists "${zone}"

	local config
	for config in $(zone_configs_list "${zone}"); do
		local config_hook="$(zone_config_get_hook "${zone}" "${config}")"
		assert isset config_hook

		hook_config_exec "${config_hook}" "${cmd}" "${zone}" "${config}" $@
	done
}

function zone_configs_up() {
	zone_configs_cmd "up" $@
}

function zone_configs_down() {
	zone_configs_cmd "down" $@
}

function zone_configs_status() {
	zone_configs_cmd "status" $@
}

function zone_configs_list() {
	local zone=${1}

	local config
	for config in $(zone_dir ${zone})/configs/*; do
		[ -e "${config}" ] || continue

		basename ${config}
	done
}

function zone_config_get_hook() {
	assert [ $# -eq 2 ]

	local zone="${1}"
	assert isset zone

	local config="${2}"
	assert isset config

	local HOOK
	zone_config_settings_read "${zone}" "${config}" \
		--ignore-superfluous-settings HOOK

	print "${HOOK}"
}

function zone_has_ip() {
	device_has_ip $@
}

function zone_db() {
	local zone=${1}
	local action=${2}
	shift 2

	case "${action}" in
		starting|started|stopping|stopped)
			db_connection_update ${zone} ${action}
			;;
	esac
}

function zone_is_up() {
	local zone=${1}

	device_is_up ${zone}
}

function zone_is_down() {
	! zone_is_up $@
}

function zone_get_supported_port_hooks() {
	local zone=${1}

	local hook=$(zone_get_hook ${zone})

	hook_zone_ports_get_all ${hook}
}

function zone_get_supported_config_hooks() {
	hook_config_get_all
}

function zone_file() {
	local zone=${1}

	assert isset zone

	echo "$(zone_dir ${zone})/settings"
}

function zone_settings_read() {
	local zone=${1}
	assert isset zone
	shift

	local args
	if [ $# -eq 0 ] && [ -n "${HOOK_SETTINGS}" ]; then
		list_append args ${HOOK_SETTINGS}
	else
		list_append args $@
	fi

	# Save the HOOK variable.
	local hook="${HOOK}"

	settings_read "$(zone_file "${zone}")" ${args}

	# Restore hook.
	HOOK="${hook}"
}

function zone_settings_write() {
	local zone="${1}"
	assert isset zone

	local args
	if function_exists "hook_check_settings"; then
		list_append args "--check=\"hook_check_settings\""
	fi
	list_append args ${HOOK_SETTINGS}

	settings_write "$(zone_file ${zone})" ${args}
}

function zone_settings_set() {
	local zone=${1}
	shift
	local args="$@"

	assert isset zone

	(
		zone_settings_read ${zone}

		for arg in ${args}; do
			eval "${arg}"
		done
	
		zone_settings_write ${zone}
	)
}

function zone_settings_get() {
	local zone=${1}
	local key=${2}

	assert isset zone
	assert isset key

	(
		zone_settings_read "${zone}" "${key}" \
			--ignore-superfluous-settings

		echo "${!key}"
	)
}

function zone_config_settings_read() {
	assert [ $# -gt 2 ]

	local zone="${1}"
	local config="${2}"
	shift 2

	local path="$(zone_dir "${zone}")/configs/${config}"
	settings_read "${path}" "$@"
}

function zone_config_settings_write() {
	assert [ $# -gt 2 ]

	local zone="${1}"
	local config="${2}"
	shift 2

	local path="$(zone_dir "${zone}")/configs/${config}"
	settings_write "${path}" "$@"
}

function zone_port_settings_read() {
	assert [ $# -ge 2 ]

	local zone="${1}"
	local port="${2}"
	shift 2

	local args
	if [ $# -eq 0 ] && [ -n "${HOOK_PORT_SETTINGS}" ]; then
		list_append args ${HOOK_PORT_SETTINGS}
	else
		list_append args $@
	fi

	local path="$(zone_dir "${zone}")/ports/${port}"
	settings_read "${path}" ${args}
}

function zone_port_settings_write() {
	assert [ $# -ge 2 ]

	local zone="${1}"
	local port="${2}"
	shift 2

	local args
	if function_exists "hook_check_port_settings"; then
		list_append args "--check=\"hook_check_port_settings\""
	fi
	list_append args ${HOOK_PORT_SETTINGS}

	local path="$(zone_dir "${zone}")/ports/${port}"
	settings_write "${path}" ${args}
}

function zone_port_settings_remove() {
	assert [ $# -eq 2 ]

	local zone="${1}"
	local port="${2}"

	local path="$(zone_dir "${zone}")/ports/${port}"
	settings_remove "${path}"
}

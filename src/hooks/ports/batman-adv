#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2013 Michael Tremer                                           #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

. /usr/lib/network/header-port

HOOK_SETTINGS="HOOK ADDRESS SLAVES"

PORT_CHILDREN_VAR="SLAVES"

ADDRESS=$(mac_generate)
SLAVES=

function hook_check() {
	assert isset ADDRESS
	assert ismac ADDRESS
}

function hook_create() {
	while [ $# -gt 0 ]; do
		case "${1}" in
			--address=*)
				ADDRESS="$(cli_get_val ${1})"
				;;
			--slaves=*)
				SLAVES="$(cli_get_val ${1})"
				;;
			*)
				warning "Ignoring unknown argument '${1}'"
				;;
		esac
		shift
	done

	local port=$(port_find_free ${PORT_PATTERN_BATMAN_ADV})
	assert isset port

	config_write $(port_file ${port}) ${HOOK_SETTINGS}

	exit ${EXIT_OK}
}

function hook_edit() {
	local port=${1}
	assert isset port
	shift

	config_read $(port_file ${port})

	while [ $# -gt 0 ]; do
		case "${1}" in
			--address=*)
				ADDRESS="$(cli_get_val ${1})"
				;;
			--add-slave=*)
				SLAVES="${SLAVES} $(cli_get_val ${1})"
				;;
			--del-slave=*)
				local slave="$(cli_get_val ${1})"

				local s slaves
				for s in ${SLAVES}; do
					[ "${slave}" = "${s}" ] && continue
					slaves="${slaves} ${s}"
				done
				SLAVES="${slaves}"
				;;
			*)
				warning "Unknown argument '${1}'"
				;;
		esac
		shift
	done

	config_write $(port_file ${port}) ${HOOK_SETTINGS}

	exit ${EXIT_OK}
}

function hook_up() {
	local port=${1}
	assert isset port

	config_read $(port_file ${port})

	# This cannot be started manually, but is created automatically
	# when a slave device is brought up and set up by _hotplug.

	local slave
	for slave in ${SLAVES}; do
		port_up "${slave}"
	done

	# If the port has been created (does not happen, when there are
	# no slaves), we bring it up.
	if device_exists "${port}"; then
		# Set the address.
		device_set_address "${port}" "${ADDRESS}"

		device_set_up "${port}"
	fi

	exit ${EXIT_OK}
}

function hook_down() {
	local port=${1}
	assert isset port

	config_read $(port_file ${port})

	local slave
	for slave in ${SLAVES}; do
		port_down "${slave}"
	done

	exit ${EXIT_OK}
}

function hook_hotplug() {
	local port=${1}
	assert isset port

	local phy=${2}
	assert isset phy

	# Bring up the device.
	port_up "${port}"

	exit ${EXIT_OK}
}

function hook_status() {
	local port=${1}
	assert isset port

	cli_device_headline "${port}" --long

	cli_headline 2 "B.A.T.M.A.N."

	# Routing algorithm
	cli_print_fmt1 2 "Routing Algorithm" \
		"$(batman_adv_get_routing_algorithm "${port}")"

	# Space
	cli_space

	# Originator interval
	cli_print_fmt1 2 "Originator Interval" \
		"$(batman_adv_get_originator_interval "${port}") ms"

	# Aggregated originator messages
	batman_adv_get_aggregated_ogms "${port}"
	cli_print_fmt1 2 "Aggregated Originator Messages" "$(cli_print_bool $?)"

	# AP isolation
	batman_adv_get_ap_isolation "${port}"
	cli_print_fmt1 2 "Access Point Isolation" "$(cli_print_bool $?)"

	# Bonding mode
	batman_adv_get_bonding_mode "${port}"
	cli_print_fmt1 2 "Bonding Mode" "$(cli_print_bool $?)"

	# Bridge loop avoidance
	batman_adv_get_bridge_loop_avoidance "${port}"
	cli_print_fmt1 2 "Bridge Loop Avoidance" "$(cli_print_bool $?)"

	# Distributed ARP table
	batman_adv_get_distributed_arp_table "${port}"
	cli_print_fmt1 2 "Distributed ARP Table" "$(cli_print_bool $?)"

	# Fragmentation
	batman_adv_get_fragmentation "${port}"
	cli_print_fmt1 2 "Fragmentation" "$(cli_print_bool $?)"

	# Hop penalty
	cli_print_fmt1 2 "Hop Penalty" \
		"$(batman_adv_get_hop_penalty "${port}")"
	cli_space

	# Gateway
	cli_headline 3 "Gateway"

	# Gateway mode
	batman_adv_get_gateway_mode "${port}"
	local gw_enabled=$?

	cli_print_fmt1 3 "Enabled" "$(cli_print_bool ${gw_enabled})"

	if [ ${gw_enabled} -eq ${EXIT_TRUE} ]; then
		cli_print_fmt1 3 "Bandwidth" \
			"$(batman_adv_get_gateway_bandwidth "${port}")"
		cli_print_fmt1 3 "Selection Class" \
			"$(batman_adv_get_gateway_selection_class "${port}")"
	fi

	cli_space

	exit ${EXIT_OK}
}

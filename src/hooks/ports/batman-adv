#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2013 Michael Tremer                                           #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

. /usr/lib/network/header-port

HOOK_SETTINGS="HOOK ADDRESS SLAVES"

PORT_CHILDREN_VAR="SLAVES"

ADDRESS=$(mac_generate)
SLAVES=

hook_check_settings() {
	assert isset ADDRESS
	assert ismac ADDRESS
}

hook_new() {
	while [ $# -gt 0 ]; do
		case "${1}" in
			--address=*)
				ADDRESS="$(cli_get_val "${1}")"
				;;
			--slaves=*)
				SLAVES="$(cli_get_val "${1}")"
				;;
			*)
				warning "Ignoring unknown argument '${1}'"
				;;
		esac
		shift
	done

	local port=$(port_find_free ${PORT_PATTERN_BATMAN_ADV})
	assert isset port

	port_settings_write "${port}" ${HOOK_SETTINGS}

	exit ${EXIT_OK}
}

hook_edit() {
	local port=${1}
	assert isset port
	shift

	port_settings_read "${port}"

	while [ $# -gt 0 ]; do
		case "${1}" in
			--address=*)
				ADDRESS="$(cli_get_val "${1}")"
				;;
			--add-slave=*)
				SLAVES="${SLAVES} $(cli_get_val "${1}")"
				;;
			--del-slave=*)
				local slave="$(cli_get_val "${1}")"

				local s slaves
				for s in ${SLAVES}; do
					[ "${slave}" = "${s}" ] && continue
					slaves="${slaves} ${s}"
				done
				SLAVES="${slaves}"
				;;
			*)
				warning "Unknown argument '${1}'"
				;;
		esac
		shift
	done

	port_settings_write "${port}" ${HOOK_SETTINGS}

	exit ${EXIT_OK}
}

hook_create() {
	local port="${1}"
	assert isset port

	port_settings_read "${port}" ${HOOK_SETTINGS}

	# Create a new batman-adv device
	batman_adv_add "${port}" || exit ${?}

	# Set the address.
	device_set_address "${port}" "${ADDRESS}"

	exit ${EXIT_OK}
}

hook_remove() {
	local port="${1}"
	assert isset port

	port_settings_read "${port}" ${HOOK_SETTINGS}

	# Remove the batman-adv device
	batman_adv_delete "${port}"

	exit ${EXIT_OK}
}

hook_hotplug() {
	local port="${1}"
	assert isset port

	case "$(hotplug_action)" in
		add)
			# Handle events of the same interface
			if hotplug_event_port_is_interface "${port}"; then
				# Bring up all slaves
				# They will be attached by their own hotplug event
				local slave
				for slave in $(port_get_slaves "${port}"); do
					port_create "${slave}"
				done

				exit ${EXIT_OK}

			# Handle slave devices that have just been created and
			# attach them.
			elif hotplug_event_interface_is_slave_of_port "${port}"; then
				batman_adv_attach "${port}" "${INTERFACE}"

				# If the batman-adv is already up, we will bring
				# up the slave we just added as well.
				if port_is_up "${port}"; then
					port_up "${INTERFACE}"
				fi
			fi

			exit ${EXIT_OK}
			;;

		remove)
			if hotplug_event_port_is_interface "${port}"; then
				# Bring down all slaves when the batman device went down
				local slave
				for slave in $(port_get_slaves "${port}"); do
					port_remove "${slave}"
				done

				exit ${EXIT_OK}
			fi
			;;
	esac
	exit ${EXIT_NOT_HANDLED}
}

hook_status() {
	local port=${1}
	assert isset port

	cli_device_headline "${port}" --long

	cli_headline 2 "B.A.T.M.A.N."

	# Routing algorithm
	cli_print_fmt1 2 "Routing Algorithm" \
		"$(batman_adv_get_routing_algorithm "${port}")"

	# Space
	cli_space

	# Originator interval
	cli_print_fmt1 2 "Originator Interval" \
		"$(batman_adv_get_originator_interval "${port}") ms"

	# Aggregated originator messages
	batman_adv_get_aggregated_ogms "${port}"
	cli_print_fmt1 2 "Aggregated Originator Messages" "$(cli_print_bool $?)"

	# AP isolation
	batman_adv_get_ap_isolation "${port}"
	cli_print_fmt1 2 "Access Point Isolation" "$(cli_print_bool $?)"

	# Bonding mode
	batman_adv_get_bonding_mode "${port}"
	cli_print_fmt1 2 "Bonding Mode" "$(cli_print_bool $?)"

	# Bridge loop avoidance
	batman_adv_get_bridge_loop_avoidance "${port}"
	cli_print_fmt1 2 "Bridge Loop Avoidance" "$(cli_print_bool $?)"

	# Distributed ARP table
	batman_adv_get_distributed_arp_table "${port}"
	cli_print_fmt1 2 "Distributed ARP Table" "$(cli_print_bool $?)"

	# Fragmentation
	batman_adv_get_fragmentation "${port}"
	cli_print_fmt1 2 "Fragmentation" "$(cli_print_bool $?)"

	# Hop penalty
	cli_print_fmt1 2 "Hop Penalty" \
		"$(batman_adv_get_hop_penalty "${port}")"
	cli_space

	# Gateway
	cli_headline 3 "Gateway"

	# Gateway mode
	batman_adv_get_gateway_mode "${port}"
	local gw_enabled=$?

	cli_print_fmt1 3 "Enabled" "$(cli_print_bool ${gw_enabled})"

	if [ ${gw_enabled} -eq ${EXIT_TRUE} ]; then
		cli_print_fmt1 3 "Bandwidth" \
			"$(batman_adv_get_gateway_bandwidth "${port}")"
		cli_print_fmt1 3 "Selection Class" \
			"$(batman_adv_get_gateway_selection_class "${port}")"
	fi

	cli_space

	exit ${EXIT_OK}
}

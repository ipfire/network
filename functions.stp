#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2010  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

function stp_init() {
	module_load stp

	assert binary_exists brctl
	assert binary_exists rstpctl
}

init_register stp_init

function __rstpctl_bridge_get() {
	local bridge=${1}
	local param=${2}

	assert isset bridge
	assert isset param

	local key
	local val
	rstpctl dumpbridge ${bridge} | \
		while read bridge key val; do
		if [ "${key}" = "${param}" ]; then
			echo "${val}"
			return ${EXIT_OK}
		fi
	done

	return ${EXIT_ERROR}
}

function __rstpctl_port_get() {
	local bridge=${1}
	local port=${2}
	local param=${3}

	assert isset bridge
	assert isset port
	assert isset param

	local key
	local val
	rstpctl dumpports ${bridge} | \
		while read por key val; do
		if [ "${port}" = "${por}" -a "${key}" = "${param}" ]; then
			echo "${val}"
			return ${EXIT_OK}
		fi
	done

	return ${EXIT_ERROR}
}

function stp_enable() {
	local bridge=${1}

	assert isset bridge
	assert zone_exists ${bridge}

	brctl stp ${bridge} on

	local mode=$(zone_config_get ${bridge} STP_MODE)

	case "${mode}" in
		stp)
			rstpctl setforcevers ${bridge} slow
			;;
		rstp)
			rstpctl setforcevers ${bridge} normal
			;;
		*)
			log WARNING "Unknown protocol version: ${mode}."
			log WARNING "Using default mode."
			;;
	esac
}

function stp_disable() {
	local bridge=${1}

	assert isset bridge
	assert zone_exists ${bridge}

	brctl stp ${bridge} off
}

function stp_bridge_get_protocol() {
	local bridge=${1}

	assert isset bridge

	local enabled=$(__device_get_file ${bridge} "bridge/stp_state")
	if ! enabled ${enabled}; then
		return ${EXIT_OK}
	fi

	local mode=$(__rstpctl_bridge_get ${bridge} protocol_version)

	case "${mode}" in
		0)
			echo "stp"
			;;
		2)
			echo "rstp"
			;;
		# When rstpctl has an error, we assume that rstpd is not running and
		# return the slow mode.
		"")
			echo "stp"
			;;
	esac
}

function stp_bridge_set_protocol() {
	: XXX WANTED
}

function stp_bridge_get_id() {
	local bridge=${1}

	assert isset bridge

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			__rstpctl_bridge_get ${bridge} "id"
			return ${EXIT_OK}
			;;
		stp)
			__device_get_file ${bridge} "bridge/bridge_id"
			return ${EXIT_OK}
			;;
	esac

	return ${EXIT_ERROR}
}

function stp_bridge_get_forward_delay() {
	local bridge=${1}

	assert isset bridge

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			__rstpctl_bridge_get ${bridge} "bridge_forward_delay"
			return ${EXIT_OK}
			;;
		stp)
			__device_get_file ${bridge} "bridge/forward_delay"
			return ${EXIT_OK}
			;;
	esac

	return ${EXIT_ERROR}
}

function stp_bridge_get_hello_time() {
	local bridge=${1}

	assert isset bridge

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			__rstpctl_bridge_get ${bridge} "bridge_hello_time"
			return ${EXIT_OK}
			;;
		stp)
			__device_get_file ${bridge} "bridge/hello_time"
			return ${EXIT_OK}
			;;
	esac

	return ${EXIT_ERROR}
}

function stp_bridge_get_max_age() {
	local bridge=${1}

	assert isset bridge

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			__rstpctl_bridge_get ${bridge} "bridge_max_age"
			return ${EXIT_OK}
			;;
		stp)
			__device_get_file ${bridge} "bridge/max_age"
			return ${EXIT_OK}
			;;
	esac

	return ${EXIT_ERROR}
}

function stp_bridge_get_designated_root() {
	local bridge=${1}
	local output

	assert isset bridge

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			output=$(__rstpctl_bridge_get ${bridge} "designated_root")
			;;
		stp)
			output=$(__device_get_file ${bridge} "bridge/root_id")
			;;
	esac

	if ! isset output; then
		return ${EXIT_ERROR}
	fi

	mac_format "${output:5:12}"

	return ${EXIT_OK}
}

function stp_bridge_get_root_path_cost() {
	local bridge=${1}

	assert isset bridge

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			__rstpctl_bridge_get ${bridge} "root_path_cost"
			return ${EXIT_OK}
			;;
		stp)
			__device_get_file ${bridge} "bridge/root_path_cost"
			return ${EXIT_OK}
			;;
	esac

	return ${EXIT_ERROR}
}

function stp_bridge_get_root_port_id() {
	local bridge=${1}

	assert isset bridge

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			__rstpctl_bridge_get ${bridge} "root_port"
			return ${EXIT_OK}
			;;
		stp)
			__device_get_file ${bridge} "bridge/root_port"
			return ${EXIT_OK}
			;;
	esac

	return ${EXIT_ERROR}
}

function stp_bridge_get_root_port() {
	local bridge=${1}

	assert isset bridge

	local id=$(stp_bridge_get_root_port_id ${bridge})

	local member
	local member_id
	for member in $(bridge_get_members ${bridge}); do
		member_id=$(stp_port_get_id ${bridge} ${member})

		if [ "${id}" = "${member_id}" ]; then
			echo "${member}"
			return ${EXIT_OK}
		fi
	done

	return ${EXIT_ERROR}
}

function stp_bridge_is_root() {
	local bridge=${1}

	assert isset bridge

	[ -n "$(stp_bridge_get_root_port ${bridge})" ]
}

function stp_bridge_get_priority() {
	local bridge=${1}

	assert isset bridge

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			local output=$(__rstpctl_bridge_get ${bridge} "root_path_cost")
			dec "${output:0:4}"
			return ${EXIT_OK}
			;;
		stp)
			__device_get_file ${bridge} "bridge/priority"
			return ${EXIT_OK}
			;;
	esac

	return ${EXIT_ERROR}
}

function stp_bridge_get_topology_change_count() {
	local bridge=${1}

	assert isset bridge

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			__rstpctl_bridge_get ${bridge} "topology_change_count"
			return ${EXIT_OK}
			;;
		stp)
			__device_get_file ${bridge} "bridge/topology_change"
			return ${EXIT_OK}
			;;
	esac

	return ${EXIT_ERROR}
}

function stp_bridge_get_topology_change_timer() {
	local bridge=${1}

	assert isset bridge

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			__rstpctl_bridge_get ${bridge} "time_since_topology_change"
			return ${EXIT_OK}
			;;
		stp)
			__device_get_file ${bridge} "bridge/topology_change_timer"
			return ${EXIT_OK}
			;;
	esac

	return ${EXIT_ERROR}
}

function stp_bridge_get_topology_change_detected() {
	local bridge=${1}

	assert isset bridge

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			__rstpctl_bridge_get ${bridge} "topology_change"
			return ${EXIT_OK}
			;;
		stp)
			__device_get_file ${bridge} "bridge/topology_change_detected"
			return ${EXIT_OK}
			;;
	esac

	return ${EXIT_ERROR}
}

# STP states
STP_STATE[0]="disabled"
STP_STATE[1]="listening"
STP_STATE[2]="learning"
STP_STATE[3]="forwarding"
STP_STATE[4]="blocking"

function stp_port_get_state() {
	local bridge=${1}
	local port=${2}
	local output

	assert isset bridge
	assert isset port

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			output=$(__rstpctl_port_get ${bridge} ${port} "state")
			;;
		stp)
			output=$(__device_get_file ${bridge} "brif/${port}/state")

			# Translate int to name
			output="${STP_STATE[${output}]}"
			;;
	esac

	if ! isset output; then
		return ${EXIT_ERROR}
	fi

	echo "${output^^}"

	return ${EXIT_OK}
}

function stp_port_get_id() {
	local bridge=${1}
	local port=${2}

	assert isset bridge
	assert isset port

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			__rstpctl_port_get ${bridge} ${port} "id"
			return ${EXIT_OK}
			;;
		stp)
			dec $(__device_get_file ${bridge} "brif/${port}/port_no")
			return ${EXIT_OK}
			;;
	esac

	return ${EXIT_ERROR}
}

function stp_port_get_cost() {
	local bridge=${1}
	local port=${2}

	assert isset bridge
	assert isset port

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			__rstpctl_port_get ${bridge} ${port} "path_cost"
			return ${EXIT_OK}
			;;
		stp)
			__device_get_file ${bridge} "brif/${port}/path_cost"
			return ${EXIT_OK}
			;;
	esac

	return ${EXIT_ERROR}
}

function stp_port_get_designated_root() {
	local bridge=${1}
	local port=${2}
	local output

	assert isset bridge
	assert isset port

	case "$(stp_bridge_get_protocol ${bridge})" in
		rstp)
			output=$(__rstpctl_port_get ${bridge} ${port} "designated_root")
			;;
		stp)
			output=$(__device_get_file ${bridge} "brif/${port}/designated_root")
			;;
	esac

	if [ -n "${output}" ]; then
		mac_format ${output:5:12}
		return ${EXIT_OK}
	fi

	return ${EXIT_ERROR}
}

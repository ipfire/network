#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2010  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

# The default mode.
#   We default to RSTP, because it has the better user experience and
#   faster convergence times. Despite of that, it completely downgradeable
#   to plain STP.
STP_DEFAULT_MODE="rstp"

# Allowed modes of the spanning tree protocol.
STP_ALLOWED_MODES="rstp stp"

function stp_enable() {
	local bridge=${1}
	local mode=${2}

	assert isset bridge
	assert zone_exists ${bridge}

	# Tell the kernel to enable STP.
	brctl stp ${bridge} on

	# Set the correct protocol version.
	if [ -z "${mode}" ]; then
		mode="${STP_DEFAULT_MODE}"
	fi
	stp_bridge_set_protocol ${bridge} ${mode}
}

function stp_disable() {
	local bridge=${1}

	assert isset bridge
	assert zone_exists ${bridge}

	brctl stp ${bridge} off
}

function stp_get_name() {
	local proto=${1}

	case "${proto}" in
		stp)
			echo "Spanning Tree Protocol"
			;;
		rstp)
			echo "Rapid Spanning Tree Protocol"
			;;
		mstp)
			echo "Multiple Spanning Tree Protocol"
			;;
	esac

	return ${EXIT_OK}
}

function stp_bridge_set_protocol() {
	local bridge=${1}
	local mode=${2}

	assert isset bridge
	assert isset mode

	if ! listmatch ${mode} ${STP_ALLOWED_MODES}; then
		log WARNING "Unknown protocol version: ${mode}."
		log WARNING "Using default mode."

		mode="${STP_DEFAULT_MODE}"
	fi

	mstpctl setforcevers ${bridge} ${mode}
	assert [ $? -eq 0 ]
}

function stp_bridge_get_protocol() {
	local bridge=${1}

	assert isset bridge

	# Let's check what the kernel is telling us about it's STP state.
	local state=$(__device_get_file ${bridge} "bridge/stp_state")

	case "${state}" in
		0)
			# STP is disabled.
			return ${EXIT_OK}
			;;
		1)
			# Kernel mode STP is running.
			echo "stp"
			return ${EXIT_OK}
			;;
		2)
			# User-space STP is running.
			;;
		*)
			log ERROR "Kernel is running in an unknown STP state."
			return ${EXIT_ERROR}
			;;
	esac

	# We get here, when STP is running in user-space mode.

	# Get the current protocol version.
	state=$(mstpctl showbridge ${bridge} | sed -n 's/  force protocol version.*\([0-9]\)/\1/p')

	case "${state}" in
		1)
			echo "stp"
			;;
		2)
			echo "rstp"
			;;
		3)
			echo "mstp"
			;;
		*)
			log ERROR "Could not determine STP version: ${state}."
			return ${EXIT_ERROR}
			;;
	esac

	return ${EXIT_OK}
}

function stp_bridge_get_id() {
	local bridge=${1}

	assert isset bridge

	__device_get_file ${bridge} "bridge/bridge_id"

	return $?
}

function stp_bridge_get_forward_delay() {
	local bridge=${1}

	assert isset bridge

	mstpctl showbridge ${bridge} | sed -n "s/  forward delay \([0-9]*\).*/\1/p"
}

function stp_bridge_set_forward_delay() {
	: # XXX WANTED
}

function stp_bridge_get_designated_root() {
	local bridge=${1}
	local output

	assert isset bridge

	local output=$(mstpctl showbridge ${bridge} | sed -n "s/  designated root \(.*\).*/\1/p")

	if ! isset output; then
		return ${EXIT_ERROR}
	fi

	echo "${output,,}"
	return ${EXIT_OK}
}

function stp_bridge_get_root_path_cost() {
	local bridge=${1}

	assert isset bridge

	mstpctl showbridge ${bridge} | sed -n "s/  path cost\s*\([0-9]*\).*/\1/p"
}

function stp_bridge_get_root_port_id() {
	local bridge=${1}

	assert isset bridge

	local root_port=$(mstpctl showbridge ${bridge} | sed -n "s/  root port\s*\([a-z0-9]*\).*/\1/p")

	# Return error, when there is no root port.
	if [ "${root_port}" = "none" ]; then
		return ${EXIT_ERROR}
	fi

	echo "${root_port}"
	return ${EXIT_OK}
}

function stp_bridge_get_root_port() {
	local bridge=${1}

	assert isset bridge

	local id=$(stp_bridge_get_root_port_id ${bridge})

	local member
	local member_id
	for member in $(bridge_get_members ${bridge}); do
		member_id=$(stp_port_get_id ${bridge} ${member})

		if [ "${id}" = "${member_id}" ]; then
			echo "${member}"
			return ${EXIT_OK}
		fi
	done

	return ${EXIT_ERROR}
}

function stp_bridge_is_root() {
	stp_bridge_get_root_port_id $@ >/dev/null
	local ret=$?

	if [ ${ret} -eq ${EXIT_ERROR} ]; then
		return ${EXIT_OK}
	fi

	return ${EXIT_ERROR}
}

function stp_bridge_get_priority() {
	local bridge=${1}

	assert isset bridge

	local id=$(stp_bridge_get_id ${bridge})

	dec "${id:0:4}"
}

function stp_bridge_get_topology_change_count() {
	local bridge=${1}

	assert isset bridge

	mstpctl showbridge ${bridge} | sed -n "s/  toplogy change count\s*\([0-9]*\)/\1/p"
}

function stp_bridge_get_topology_change_timer() {
	local bridge=${1}

	assert isset bridge

	mstpctl showbridge ${bridge} | sed -n "s/  time since topology change\s*\([0-9]*\)/\1/p"
}

function stp_bridge_get_topology_change_detected() {
	local bridge=${1}

	assert isset bridge

	local change=$(mstpctl showbridge ${bridge} | sed -n "s/  topology change\s*\(.*\)/\1/p")

	echo "${change}"
	case "${change}" in
		yes)
			return ${EXIT_OK}
			;;
		*)
			return ${EXIT_ERROR}
			;;
	esac
}

function stp_port_get_state() {
	local bridge=${1}
	local port=${2}

	assert isset bridge
	assert isset port

	local state=$(mstpctl showportdetail ${bridge} ${port} | sed -n "s/.*state\s*\([a-z]*\)/\1/p")

	echo "${state^^}"
}

function stp_port_get_id() {
	local bridge=${1}
	local port=${2}

	assert isset bridge
	assert isset port

	local id=$(__device_get_file ${bridge} "brif/${port}/port_no")

	dec ${id}

	return ${EXIT_OK}
}

function stp_port_get_cost() {
	local bridge=${1}
	local port=${2}

	assert isset bridge
	assert isset port

	mstpctl showportdetail ${bridge} ${port} | sed -n "s/  external port cost \([0-9]*\).*/\1/p"

	return ${EXIT_ERROR}
}

function stp_port_get_designated_root() {
	local bridge=${1}
	local port=${2}
	local output

	assert isset bridge
	assert isset port

	output=$(mstpctl showportdetail ${bridge} ${port} | sed -n "s/  designated root\s*\(.*\)\s*dsgn.*/\1/p")

	if [ -n "${output}" ]; then
		echo "${output,,}"
		return ${EXIT_OK}
	fi

	return ${EXIT_ERROR}
}

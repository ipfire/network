#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2010  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

# The default mode.
#   We default to RSTP, because it has the better user experience and
#   faster convergence times. Despite of that, it completely downgradeable
#   to plain STP.
STP_DEFAULT_MODE="rstp"

# Allowed modes of the spanning tree protocol.
STP_ALLOWED_MODES="rstp stp"

function stp_enable() {
	local bridge=${1}
	assert isset bridge

	# Tell the kernel to enable STP.
	print 1 > ${SYS_CLASS_NET}/${bridge}/bridge/stp_state
}

function stp_disable() {
	local bridge=${1}
	assert isset bridge

	# Tell the kernel to disable STP.
	print 0 > ${SYS_CLASS_NET}/${bridge}/bridge/stp_state
}

function stp_is_enabled() {
	local bridge=${1}
	assert isset bridge

	local state=$(__device_get_file ${bridge} bridge/stp_state)

	case "${state}" in
		0)
			return ${EXIT_FALSE}
			;;
		*)
			return ${EXIT_TRUE}
			;;
	esac
}

function stp_get_name() {
	local proto=${1}

	case "${proto}" in
		stp)
			echo "Spanning Tree Protocol"
			;;
		rstp)
			echo "Rapid Spanning Tree Protocol"
			;;
		mstp)
			echo "Multiple Spanning Tree Protocol"
			;;
	esac

	return ${EXIT_OK}
}

function stp_bridge_get_protocol() {
	local bridge=${1}

	assert isset bridge

	# Let's check what the kernel is telling us about it's STP state.
	local state=$(__device_get_file ${bridge} "bridge/stp_state")

	case "${state}" in
		0)
			# STP is disabled.
			return ${EXIT_OK}
			;;
		1)
			# Kernel mode STP is running.
			echo "stp"
			return ${EXIT_OK}
			;;
		2)
			# User-space STP is running.
			;;
		*)
			log ERROR "Kernel is running in an unknown STP state."
			return ${EXIT_ERROR}
			;;
	esac

	# We get here, when STP is running in user-space mode.

	# Get the current protocol version.
	mstpctl showbridge ${bridge} force-protocol-version

	return ${EXIT_OK}
}

function stp_bridge_get_id() {
	local bridge=${1}
	assert isset bridge

	__device_get_file ${bridge} "bridge/bridge_id"

	return $?
}

function stp_bridge_get_forward_delay() {
	local bridge=${1}

	assert isset bridge

	mstpctl showbridge ${bridge} forward-delay
}

function stp_bridge_set_forward_delay() {
	local bridge=${1}
	assert isset bridge

	local fdelay=${2}
	assert isinteger fdelay

	# Check if the setting we want is already set.
	local current_fdelay=$(stp_bridge_get_forward_delay ${bridge})
	[ ${fdelay} -eq ${current_fdelay} ] && return ${EXIT_OK}

	# The smallest value that may be set is 2.
	if [ ${fdelay} -lt 2 ]; then
		fdelay=2
	fi

	# Set the new value.
	log INFO "Changing forward delay for '${bridge}': ${current_fdelay} --> ${fdelay}."
	brctl setfd ${bridge} ${fdelay}

	return ${EXIT_OK}
}

function stp_bridge_get_hello_time() {
	local bridge=${1}
	assert isset bridge

	local ht=$(__device_get_file ${bridge} "bridge/hello_time")

	# ht is now in seconds * 100.
	local split=$((${#ht} - 2))
	ht="${ht:0:${split}}.${ht:${split}:2}"

	# Round the output.
	printf "%.0f\n" "${ht}"
}

function stp_bridge_set_hello_time() {
	local bridge=${1}
	assert isset bridge

	local hello=${2}
	assert isinteger hello

	# Check if the setting we want is already set.
	local current_hello=$(stp_bridge_get_hello_time ${bridge})
	[ ${hello} -eq ${current_hello} ] && return ${EXIT_OK}

	# Set the new value.
	log INFO "Changing hello time for '${bridge}': ${current_hello} --> ${hello}."
	brctl sethello ${bridge} ${hello}

	return ${EXIT_OK}
}

function stp_bridge_get_max_age() {
	local bridge=${1}
	assert isset bridge

	local maxage=$(__device_get_file ${bridge} "bridge/max_age")

	# maxage is now in seconds * 100.
	local split=$((${#maxage} - 2))
	maxage="${maxage:0:${split}}.${maxage:${split}:2}"

	# Round the output.
	printf "%.0f\n" "${maxage}"
}

function stp_bridge_set_max_age() {
	local bridge=${1}
	assert isset bridge

	local maxage=${2}
	assert isinteger maxage

	# Check if the setting we want is already set.
	local current_maxage=$(stp_bridge_get_max_age ${bridge})
	[ ${maxage} -eq ${current_maxage} ] && return ${EXIT_OK}

	# Set the new value.
	log INFO "Changing max age for '${bridge}': ${current_maxage} --> ${maxage}."
	brctl setmaxage ${bridge} ${maxage}

	return ${EXIT_OK}
}

function stp_bridge_get_priority() {
	local bridge=${1}
	assert isset bridge

	__device_get_file ${bridge} "bridge/priority"
}

function stp_bridge_set_priority() {
	local bridge=${1}
	assert isset bridge

	local priority=${2}
	assert isinteger priority

	# Check if the setting we want is already set.
	local current_priority=$(stp_bridge_get_priority ${bridge})
	[ ${priority} -eq ${current_priority} ] && return ${EXIT_OK}

	# Set the new value.
	log INFO "Changing priority for '${bridge}': ${current_priority} --> ${priority}."
	brctl setbridgeprio ${bridge} ${priority}

	return ${EXIT_OK}
}

function stp_bridge_get_designated_root() {
	local bridge=${1}
	local output

	assert isset bridge

	local output=$(mstpctl showbridge ${bridge} designated-root)

	if ! isset output; then
		return ${EXIT_ERROR}
	fi

	echo "${output,,}"
	return ${EXIT_OK}
}

function stp_bridge_get_root_path_cost() {
	local bridge=${1}

	assert isset bridge

	mstpctl showbridge ${bridge} path-cost
}

function stp_bridge_get_root_port_id() {
	local bridge=${1}

	assert isset bridge

	local root_port=$(mstpctl showbridge ${bridge} root-port)

	# Return error, when there is no root port.
	if [ "${root_port}" = "none" ]; then
		return ${EXIT_ERROR}
	fi

	echo "${root_port}"
	return ${EXIT_OK}
}

function stp_bridge_get_root_port() {
	local bridge=${1}

	assert isset bridge

	local id=$(stp_bridge_get_root_port_id ${bridge})

	local member
	local member_id
	for member in $(bridge_get_members ${bridge}); do
		member_id=$(stp_port_get_id ${bridge} ${member})

		if [ "${id}" = "${member_id}" ]; then
			echo "${member}"
			return ${EXIT_OK}
		fi
	done

	return ${EXIT_ERROR}
}

function stp_bridge_is_root() {
	stp_bridge_get_root_port_id $@ >/dev/null
	local ret=$?

	if [ ${ret} -eq ${EXIT_ERROR} ]; then
		return ${EXIT_OK}
	fi

	return ${EXIT_ERROR}
}

function stp_bridge_get_priority() {
	local bridge=${1}

	assert isset bridge

	local id=$(stp_bridge_get_id ${bridge})

	dec "${id:0:4}"
}

function stp_bridge_get_topology_change_count() {
	local bridge=${1}

	assert isset bridge

	mstpctl showbridge ${bridge} topology-change-count
}

function stp_bridge_get_topology_change_timer() {
	local bridge=${1}

	assert isset bridge

	mstpctl showbridge ${bridge} time-since-topology-change
}

function stp_bridge_get_topology_change_detected() {
	local bridge=${1}

	assert isset bridge

	local change=$(mstpctl showbridge ${bridge} topology-change)

	echo "${change}"
	case "${change}" in
		yes)
			return ${EXIT_OK}
			;;
		*)
			return ${EXIT_ERROR}
			;;
	esac
}

function stp_port_get_state() {
	local bridge=${1}
	local port=${2}

	assert isset bridge
	assert isset port

	local state=$(mstpctl showportdetail ${bridge} ${port} state)

	echo "${state^^}"
}

function stp_port_get_id() {
	local bridge=${1}
	local port=${2}

	assert isset bridge
	assert isset port

	local id=$(__device_get_file ${bridge} "brif/${port}/port_no")

	dec ${id}

	return ${EXIT_OK}
}

function stp_port_get_cost() {
	local bridge=${1}
	local port=${2}

	assert isset bridge
	assert isset port

	mstpctl showportdetail ${bridge} ${port} external-port-cost

	return ${EXIT_ERROR}
}

function stp_port_get_designated_root() {
	local bridge=${1}
	local port=${2}
	local output

	assert isset bridge
	assert isset port

	output=$(mstpctl showportdetail ${bridge} ${port} designated-root)

	if [ -n "${output}" ]; then
		echo "${output,,}"
		return ${EXIT_OK}
	fi

	return ${EXIT_ERROR}
}

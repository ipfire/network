#!/bin/bash
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2010  Michael Tremer & Christian Schmidt                      #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

function routing_has_default() {
	ip route | grep -q "^default"
}

function routing_default_update() {
	local routes

	local zones=$(zones_get_nonlocal)
	if [ -z "${zones}" ]; then
		zones=$(zones_get_local)
	fi

	local gateway
	local weight
	local zone

	local proto="ipv4"

	for zone in ${zones}; do
		# Skip if zone is not up
		routing_db_exists ${zone} ${proto} || continue

		if [ "$(routing_db_get ${zone} ${proto} active)" = "1" ]; then
			gateway=$(routing_db_get ${zone} ${proto} remote-ip-address)
			weight=$(routing_db_get ${zone} ${proto} weight)

			routes="${routes} nexthop via ${gateway}"

			if [ -n "${weight}" ]; then
				routes="${routes} weight ${weight}"
			fi
		else
			log DEBUG "Ignoring zone '${zone}' which is not active."
		fi
	done

	if [ -z "${routes}" ]; then
		log INFO "Removing default route."

		if routing_has_default; then
			ip route del default
		fi
		return ${EXIT_OK}
	fi

	# Remove too much spaces.
	routes=$(echo ${routes})

	log INFO "Setting default route: ${routes}"

	ip route replace default ${routes}
}

function routing_table_exists() {
	local zone=${1}

	grep -q "${zone}$" < /etc/iproute2/rt_tables
}

function routing_table_create() {
	local zone=${1}

	if routing_table_exists ${zone}; then
		return ${EXIT_OK}
	fi

	log INFO "Creating routing table for zone '${zone}'"

	local id=$(( ${zone#red} + 1 ))

	echo "${id}	${zone}" >> /etc/iproute2/rt_tables
}

function routing_table_remove() {
	: # XXX do we need this?
}

function routing_db_path() {
	local zone=${1}
	local proto=${2}

	assert isset zone
	assert isset proto
	assert isoneof proto ${IP_SUPPORTED_PROTOCOLS}

	echo "${ROUTING_DB_DIR}/${zone}/${proto}"
}

function routing_db_exists() {
	[ -d "$(routing_db_path $@)" ]
}

function routing_db_create() {
	routing_db_exists $@ && return ${EXIT_OK}

	mkdir -p $(routing_db_path $@)
}

function routing_db_remove() {
	rm -rf $(routing_db_path $@)
}

function routing_db_set() {
	local zone=${1}
	local proto=${2}
	local parameter=${3}
	shift 3

	local value="$@"

	log INFO "Updating database (${zone} - ${proto}): ${parameter} = ${value}"

	routing_db_create ${zone} ${proto}

	echo "${value}" > $(routing_db_path ${zone} ${proto})/${parameter}
}

function routing_db_get() {
	local zone=${1}
	local proto=${2}
	local parameter=${3}
	shift 3

	cat $(routing_db_path ${zone} ${proto})/${parameter} 2>/dev/null
}

function routing_db_from_ppp() {
	local zone=${1}
	local proto=${2}

	assert isset zone
	assert isset proto

	# Save ppp configuration
	routing_db_set ${zone} ${proto} type "ppp"
	routing_db_set ${zone} ${proto} local-ip-address ${PPP_IPLOCAL}
	routing_db_set ${zone} ${proto} remote-ip-address ${PPP_IPREMOTE}

	routing_db_set ${zone} ${proto} dns ${PPP_DNS1} ${PPP_DNS2}

	routing_db_set ${zone} ${proto} remote-address ${PPP_MACREMOTE,,}
}

function routing_update() {
	local zone=${1}
	assert isset zone

	# Nothing to do for local zones.
	if zone_is_local ${zone}; then
		return ${EXIT_OK}
	fi

	local proto=${2}
	local table=${zone}
	assert isset proto

	# Create routing table if not exists
	routing_table_create ${table}

	log DEBUG "Flushing routing table ${table}"
	cmd ip route flush table ${table}

	local local_ip_address=$(routing_db_get ${zone} ${proto} local-ip-address)

	# XXX does not work.
	#log DEBUG "Adding route for subnet ${local_ip_address} to table ${table}"
	#cmd ip route add table ${table} ${local_ip_address} dev ${zone}

	local remote_ip_address=$(routing_db_get ${zone} ${proto} remote-ip-address)

	if isset remote_ip_address; then
		log DEBUG "Adding default route for table ${table}"

		cmd ip route add table ${table} default nexthop via ${remote_ip_address}
	fi

	cmd ip rule add from ${local_ip_address} lookup ${table}
}
